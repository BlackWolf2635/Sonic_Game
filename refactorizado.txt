1.-NetworkManager
	- Proposito:
		gestionar conexiones de red (TCP/UDP), descubrimiento de 				servidores, y comunicacion entre host/cliente
	- funcionamiento:
		Como Host:
			-Crea ServerSocket TCP y DatagramSocket UDP
			-Anuncia su presencia mediante broadcast UDP 			 			 (announceServer())
			-Acepta conexiones de clientes (acceptClients())
			-Gestiona hilos para recibir datos UDP/TCP

		Como Cliente:
			-Busca servidores (discoverServer())
			-Establece conexión TCP y configura puerto UDP
			-Inicia hilos para recibir datos

	- Interacciones:
		JuegoSonic: Clase principal que lo instancia
		GameScreen: Recibe/envía estados del juego
		InputState/GameState: Serializa/deserializa datos
		ClientConnection: Gestiona conexiones individuales

	- Problemas actuales:
		Gestión compleja de múltiples hilos sin pool
		Serialización Java ineficiente
		Falta manejo de paquetes perdidos
		Acoplamiento con lógica de juego

2.-GameServer (nueva)
	- Proposito:
		Servidor dedicado con gameloop centralizado y gestion de red 		optimizada

	- Funcionamiento:
		1.- Inicia loop de juego a 60hz
		2.- NetworkDispatcher maneja conexiones
		3.- PhysicsService actualiza entidades
		4.- Serializacion binaria con FlatBuffers

	- Componentes clave:
		- NetworkDispatcher: Gestiona conexiones y protocolo
		- GameState: Almacena estado actual del juego
		- TaskScheduler: Ejecuta tareas periodicas (heartbeats)
	
	- Beneficios:
		- Desacoplamiento de red y logica de juego
		- Tasa de actualizacion constante
		- menos latencia con serializacion binaria

3.-GameState (Rediseñada):
	- Proposito:
		Almacenar y sincronizar el estado completo del juego 

	- Estructura optimizada:
		public class GameState {
    private final Map<Integer, PlayerState> players = new Int2ObjectOpenHashMap<>();
    private final Lock stateLock = new ReentrantLock();
    
    public PlayerState getPlayerState(int playerId) {
        stateLock.lock();
        try {
            return players.computeIfAbsent(playerId, PlayerState::new);
        } finally {
            stateLock.unlock();
        }
    }
}

	- Caracteristicas:
		- Delta - compression: solo envia cambios
		- versionado: para deteccion de desincronizacion
		- metodos merge(): para combinar actualizaciones

4.- PlayerState (Propuesta):
	- Proposito:
		Representar el estado de un judagor con maquina de estados finitos
	
	- Implementacion:
public class PlayerState {
    private Vector2 position = new Vector2();
    private CharacterState state = CharacterState.IDLE;
    private EnumSet<CharacterState> allowedTransitions = EnumSet.of(IDLE, RUNNING, JUMPING);
    
    public boolean requestStateChange(CharacterState newState) {
        if(allowedTransitions.contains(newState)) {
            this.state = newState;
            updateTransitions();
            return true;
        }
        return false;
    }
    
    private void updateTransitions() {
        allowedTransitions = switch(state) {
            case FLYING -> EnumSet.of(IDLE, LANDING);
            case USING_ABILITY -> EnumSet.noneOf(CharacterState.class);
            // ... otras reglas
        };
    }
}

	- Validaciones:
		- Impide transiciones invalidas
		- Centraliza reglas de estado

5.- AbilitySystem (Propuesta)
	- Proposito:
		Gestionar habilidades especiales mediante eventos

	- Flujo de trabajo:
		1.- Recibe evento AbilityEvent(playerid, habilidad)
		2.- Verifica estado actual del jugador
		3.- si es valido, ejecuta logica de la habilidad
		4.- actualiza GameState

	- Implementacion:
public class AbilitySystem {
    private final EventBus eventBus;
    
    public AbilitySystem() {
        eventBus = new EventBus();
        eventBus.register(new FlyHandler());
    }
    
    public void triggerAbility(int playerId, AbilityType type) {
        eventBus.post(new AbilityEvent(playerId, type));
    }
    
    private class FlyHandler {
        @Subscribe
        public void handleFly(AbilityEvent event) {
            PlayerState state = gameState.getPlayerState(event.playerId());
            if(state.canFly()) {
                // Aplicar física de vuelo
                // Actualizar estado
            }
        }
    }
}

6.-NetworkDispatcher:
	- Proposito:
		Gestionar comunicacion de red eficientemente con protocolo binario

	- Caracteristicas:
public class NetworkDispatcher {
    // Conexiones TCP para mensajes críticos
    private final Map<Integer, ClientChannel> tcpChannels;
    
    // UDP para actualizaciones rápidas
    private final UdpServer udpServer;
    
    public void send(int playerId, ByteBuffer data) {
        if(data.remaining() > 512) {
            tcpChannels.get(playerId).send(data);
        } else {
            udpServer.send(playerId, data);
        }
    }
}
	
	- Optimizaciones:
		- Priorizacion de paquetes
		- Compresion para estados grandes
		- Reconexion automatica

7.-ClientReconcilier (Propuesta):
	- Proposito:
		manejar prediccion y reconciliacion en el cliente

	- Implementacion:
public class ClientReconciler {
    private final CircularBuffer<PendingInput> inputBuffer = new CircularBuffer<>(128);
    
    public void reconcile(GameState serverState) {
        int lastProcessed = serverState.getLastProcessedInput();
        inputBuffer.discardOlderThan(lastProcessed);
        
        // Reaplicar inputs pendientes
        for(PendingInput input : inputBuffer) {
            localState.applyInput(input);
        }
    }
}

8.- EntityInterpolator (Propuesta)
	- Proposito:
		suavizar movimiento de entidades remotas.
	
	- Algoritmo:
		public Vector2 interpolate(List<EntitySnapshot> snapshots, float alpha) {
    if(snapshots.size() < 2) return snapshots.get(0).position;
    
    EntitySnapshot s0 = snapshots.get(0);
    EntitySnapshot s1 = snapshots.get(1);
    
    // Interpolación lineal
    return s0.position.cpy().lerp(s1.position, alpha);
}

Beneficios Clave del Rediseño
Estabilidad:

Máquina de estados evita combinaciones inválidas

Validación centralizada en servidor

Desempeño:

Serialización binaria (50-70% menos ancho de banda)

Delta-compression para actualizaciones

Mantenibilidad:

Sistemas desacoplados (Single Responsibility)

Código más testeable

Experiencia de Juego:

Interpolación suave para jugadores remotos

Reconciliación de predicciones locales

Menos "rubber-banding"